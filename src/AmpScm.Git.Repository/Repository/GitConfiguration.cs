using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using Amp.Buckets;
using Amp.Buckets.Git;

namespace Amp.Git.Repository
{
    public class GitConfiguration
    {
        protected GitRepository Repository { get; }
        string _gitDir;
        bool _loaded;
        int _repositoryFormatVersion;
        readonly Dictionary<(string, string?, string), string> _config = new Dictionary<(string, string?, string), string>();

        public GitConfiguration(GitRepository gitRepository, string gitDir)
        {
            Repository = gitRepository;
            _gitDir = gitDir;
            _lazy = new Lazy<GitLazyConfig>(() => new GitLazyConfig(this));
        }

        internal async ValueTask LoadAsync()
        {
            if (_loaded) return;

            using var b = FileBucket.OpenRead(Path.Combine(_gitDir, "config"));
            using var cr = new GitConfigurationReaderBucket(b);

            while (await cr.ReadConfigItem() is GitConfigurationItem item)
            {
                if (item.Group == "core" || item.Group == "extension")
                    ParseCore(item);
                _config[(item.Group, item.SubGroup, item.Key)] = item.Value ?? "\xFF";
            }
            _loaded = true;
        }

        private void ParseCore(GitConfigurationItem item)
        {
            if (item.Key == "repositoryformatversion" && item.Group == "core")
            {
                if (int.TryParse(item.Value, out var version))
                    _repositoryFormatVersion = version;
            }
        }

        internal IEnumerable<(string, string)> GetGroup(string group, string? subGroup)
        {
            if (!_loaded)
                LoadAsync().GetAwaiter().GetResult();

            group = group.ToLowerInvariant();

            foreach(var v in _config)
            {
                var (g, s, k) = v.Key;

                if (group == g && subGroup == s)
                    yield return (k, v.Value);
            }
        }

        public IEnumerable<string> GetSubGroups(string group)
        {
            if (!_loaded)
                LoadAsync().GetAwaiter().GetResult();

            group = group.ToLowerInvariant();
            HashSet<string> subGroups = new HashSet<string>(); 

            foreach(var v in _config)
            {
                var (g, s, k) = v.Key;

                if (s == null)
                    continue;

                if (group == g)
                {
                    if (!subGroups.Contains(s))
                    {
                        yield return s;
                        subGroups.Add(s);
                    }
                }
            }
        }

        public async ValueTask<int> GetIntAsync(string group, string key, int defaultValue)
        {
            await LoadAsync();

            if (_config.TryGetValue((group, null, key), out var vResult)
                && int.TryParse(vResult, out var r))
            {
                return r;
            }            
            else
                return defaultValue;
        }

        internal int GetInt(string group, string key, int defaultValue)
        {
            return GetIntAsync(group, key, defaultValue).Result;
        }

        public ValueTask<bool> GetBoolAsync(string group, string key, bool defaultValue)
        {
            return GetBoolAsync(group, subGroup: null, key, defaultValue);
        }

        public async ValueTask<bool> GetBoolAsync(string group, string subGroup, string key, bool defaultValue)
        {
            await LoadAsync();

            if (_config.TryGetValue((group, subGroup, key), out var vResult))
            {
                // As generated by 'git init'
                if (string.Equals(vResult, "true", StringComparison.OrdinalIgnoreCase))
                    return true;
                else if (string.Equals(vResult, "false", StringComparison.OrdinalIgnoreCase))
                    return false;

                // The simple no value cases
                else if (vResult == "\xFF" || vResult is null)
                    return true;
                else if (vResult != null && vResult.Length == 0)
                    return false;

                // And other documented ok
                else if (string.Equals(vResult, "yes", StringComparison.OrdinalIgnoreCase))
                    return true;
                else if (string.Equals(vResult, "on", StringComparison.OrdinalIgnoreCase))
                    return true;
                else if (string.Equals(vResult, "1", StringComparison.OrdinalIgnoreCase))
                    return true;
                else if (string.Equals(vResult, "\xFF", StringComparison.OrdinalIgnoreCase))
                    return true;
                else if (string.Equals(vResult, "no", StringComparison.OrdinalIgnoreCase))
                    return false;
                else if (string.Equals(vResult, "off", StringComparison.OrdinalIgnoreCase))
                    return false;
                
                else if (string.Equals(vResult, "0", StringComparison.OrdinalIgnoreCase))
                    return false;

                return defaultValue;
            }
            else
                return defaultValue;
        }

        public bool GetBool(string group, string key, bool defaultValue)
        {
            return GetBoolAsync(group, key, defaultValue).Result;
        }

        public bool GetBool(string group, string subGroup, string key, bool defaultValue)
        {
            return GetBoolAsync(group, subGroup, key, defaultValue).Result;
        }

        internal class GitLazyConfig
        {
            GitConfiguration Configuration { get; }
            Lazy<bool> _repositoryIsLazy;

            public GitLazyConfig(GitConfiguration config)
            {
                Configuration = config ?? throw new ArgumentNullException(nameof(config));

                _repositoryIsLazy = new Lazy<bool>(GetRepositoryIsLazy);
            }

            bool GetRepositoryIsLazy()
            {
                if (Configuration._loaded && Configuration._repositoryFormatVersion == 0)
                    return false;

                foreach (var v in Configuration.GetSubGroups("remote"))
                {
                    if (Configuration.GetBool("remote", v, "promisor", false))
                        return true;
                }

                return false;
            }

            public bool RepositoryIsLazy => _repositoryIsLazy.Value;

        }

        Lazy<GitLazyConfig> _lazy;

        internal GitLazyConfig Lazy => _lazy.Value;
    }
}
