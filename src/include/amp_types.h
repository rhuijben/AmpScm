#pragma once

#include <stdlib.h>
#include <string.h>
#include <stdarg.h>
#include <wchar.h>

#ifndef AMP_DECLARE
#define AMP_DECLARE(type) type
#endif

#ifndef AMP_DEPRECATED
#define AMP_DEPRECATED __declspec(deprecated)
#endif

#ifdef _MSC_VER
#define __attribute__(...)
#endif

#ifdef _DEBUG
#define AMP_DEBUG
#endif

#if !defined(AMP_ASSERT) && defined(AMP_DEBUG)
#include <assert.h>
#define AMP_ASSERT(x) assert(x)
#else
#define AMP_ASSERT(x) do {} while(0)
#endif

#define AMP_UNUSED(x) ((void)x)


#ifdef __cplusplus
#	define AMP_C__START extern "C" {
#	define AMP_C__END }
#	define AMP_VA_NULL nullptr
#else
#	define AMP_C__START
#	define AMP_C__END
#	define AMP_VA_NULL (void*)0
#endif

AMP_C__START /* extern "C" { */

typedef __int64 amp_status_t;
typedef char amp_boolean_t;

typedef struct amp_pool_t amp_pool_t;
typedef struct amp_allocator_t amp_allocator_t;
typedef struct amp_file_t amp_file_t;
typedef struct amp_file_handle_t amp_file_handle_t;

/* For amp_errors.h */
typedef struct amp_err_t amp_err_t;

typedef enum amp_newline_t
{
	amp_newline_none = 0,
	amp_newline_lf = 0x01,
	amp_newline_cr = 0x02,
	amp_newline_crlf = 0x04,
	amp_newline_0 = 0x08,

	amp_newline_crlf_split = 0x100, // Single '\r' without knowledge about next char

	amp_newline_any = amp_newline_lf | amp_newline_cr | amp_newline_crlf,
	amp_newline_any_split = amp_newline_any | amp_newline_0
} amp_newline_t;

typedef amp_err_t* (*amp_error_chain_func_t)(
		amp_err_t*,
		amp_pool_t* pool);

typedef const char* (*amp_error_message_func_t)(
	amp_err_t*,
	amp_pool_t* pool);

#ifndef MIN
#define MIN(x, y) (((x) < (y)) ? (x) : (y))
#endif

#ifndef MAX
#define MAX(x, y) (((x) > (y)) ? (x) : (y))
#endif


typedef struct amp_err_t
{
	/** Error value, compatible with the APR status values, but extended to 64 bit
	*  to allow our error codes in our own range
	*/
	amp_status_t status;

	/** Details from the producer of error.
	 *
	 * Note that if this error was generated by Subversion's API, you'll
	 * probably want to use AMP_err_best_message() to get a single
	 * descriptive string for this error chain (see the @a child member)
	 * or AMP_handle_error2() to print the error chain in full.  This is
	 * because Subversion's API functions sometimes add many links to
	 * the error chain that lack details (used only to produce virtual
	 * stack traces).  (Use AMP_error_purge_tracing() to remove those
	 * trace-only links from the error chain.)
	 */
	const char* message;

	/** Pointer to the error we "wrap" (may be @c NULL).  Via this
	 * member, individual error object can be strung together into an
	 * "error chain".
	 */
	struct amp_err_t* child;

	/** The pool in which this error object is allocated. Freeing this pool
	* will free the error
	*/
	amp_pool_t* pool;

	const void* message_baton;
	amp_error_message_func_t* message_func;
	
	const void* chain_producer_baton;
	amp_error_chain_func_t* chain_producer_func;

	amp_boolean_t is_trace;
	amp_boolean_t is_composed;

#ifdef AMP_DEBUG
	/** Source file where the error originated (iff @c AMP_DEBUG;
	 * undefined otherwise).
	 */
	const char* file;

	/** Source line where the error originated (iff @c AMP_DEBUG;
	 * undefined otherwise).
	 */
	long line;

	const char* func;
#endif

	/* new items may be added at the end. Use provided constructors */

} amp_err_t;


typedef struct amp_bucket_t amp_bucket_t;
typedef long long amp_off_t;

// TODO: Move
AMP_DECLARE(amp_err_t*)
amp_utf8_to_wchar(
	wchar_t** dest,
	const char* src,
	amp_pool_t* result_pool);

AMP_DECLARE(char*)
amp_wchar_to_utf8(
	const wchar_t* src,
	amp_pool_t* result_pool);

AMP_C__END

#include "amp_error.h"
#include "amp_pools.h"
