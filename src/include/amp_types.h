#pragma once

#ifndef AMP_DECLARE
#define AMP_DECLARE(type) type
#endif

#ifndef AMP_DEPRECATED
#define AMP_DEPRECATED __declspec(deprecated)
#endif

#ifdef _DEBUG
#define AMP_DEBUG
#endif

#if !defined(AMP_ASSERT) && defined(AMP_DEBUG)
#include <assert.h>
#define AMP_ASSERT(x) assert(x)
#else
#define AMP_ASSERT(x) do {} while(0)
#endif

#define AMP_UNUSED(x) ((void)x)


#ifdef __cplusplus
#	define AMP_C__START extern "C" {
#	define AMP_C__END }
#	define AMP_VA_NULL nullptr
#else
#	define AMP_C__START
#	define AMP_C__END
#	define AMP_VA_NULL (void*)0
#endif

AMP_C__START /* extern "C" { */

typedef __int64 amp_status_t;
typedef char amp_boolean_t;

/* For amp_pools.h */
struct amp_pool_t;
struct amp_allocator_t;
struct amp_file_t;
#ifndef __cplusplus
typedef struct amp_pool_t amp_pool_t;
typedef struct amp_allocator_t amp_allocator_t;
typedef struct amp_file_t amp_file_t;
#endif

/* For amp_errors.h */
typedef struct amp_error_t amp_error_t;

typedef enum amp_newline_t
{
	amp_newline_lf = 0x01,
	amp_newline_cr = 0x02,
	amp_newline_crlf = 0x04,

	amp_newline_any = amp_newline_lf | amp_newline_cr | amp_newline_crlf
} amp_newline_t;

typedef amp_error_t* (*amp_error_chain_func_t)(
		amp_error_t*,
		amp_pool_t* pool);

typedef const char* (*amp_error_message_func_t)(
	amp_error_t*,
	amp_pool_t* pool);


typedef struct amp_error_t
{
	/** Error value, compatible with the APR status values, but extended to 64 bit
	*  to allow our error codes in our own range
	*/
	amp_status_t status;

	/** Details from the producer of error.
	 *
	 * Note that if this error was generated by Subversion's API, you'll
	 * probably want to use AMP_err_best_message() to get a single
	 * descriptive string for this error chain (see the @a child member)
	 * or AMP_handle_error2() to print the error chain in full.  This is
	 * because Subversion's API functions sometimes add many links to
	 * the error chain that lack details (used only to produce virtual
	 * stack traces).  (Use AMP_error_purge_tracing() to remove those
	 * trace-only links from the error chain.)
	 */
	const char* message;

	/** Pointer to the error we "wrap" (may be @c NULL).  Via this
	 * member, individual error object can be strung together into an
	 * "error chain".
	 */
	struct amp_error_t* child;

	/** The pool in which this error object is allocated. Freeing this pool
	* will free the error
	*/
	amp_pool_t* pool;

	const void* message_baton;
	amp_error_message_func_t* message_func;
	
	const void* chain_producer_baton;
	amp_error_chain_func_t* chain_producer_func;

	/** Source file where the error originated (iff @c AMP_DEBUG;
	 * undefined otherwise).
	 */
	const char* file;

	/** Source line where the error originated (iff @c AMP_DEBUG;
	 * undefined otherwise).
	 */
	long line;

	amp_boolean_t is_trace;
	amp_boolean_t is_composed;

} amp_error_t;


typedef struct amp_bucket_t amp_bucket_t;
typedef long long amp_off_t;

AMP_C__END

#include "amp_error.h"
